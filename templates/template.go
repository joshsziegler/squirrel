package templates

import (
	"fmt"
	"io"
	"slices"
	"sort"
	"strings"

	"github.com/joshsziegler/squirrel/parser"
)

// Write the SQL-Go access layer to f, using pkgName, except for the tables in ignoredTables.
// Table sorted alphabetically (A to Z), so the resulting code will not change due to input orger.
// Otherwise, the resulting git diffs can be noisy.
func Write(f io.Writer, pkgName string, tables []*parser.Table, ignoreTables []string) {
	// Sort the tables alphabetically (A to Z)
	sort.Slice(tables, func(i, j int) bool {
		return tables[i].GoName() < tables[j].GoName()
	})
	// Write to f
	w := NewShortWriter(f)
	Header(w, pkgName)
	for _, table := range tables {
		if table.InternalUse() || slices.Contains(ignoreTables, table.SQLName()) {
			continue // skip this table
		}
		Table(w, table)
	}
}

func Header(w *ShortWriter, pkgName string) {
	w.F("// Code generated by squirrel; DO NOT EDIT.\n\n")
	w.F("package %s\n\n", pkgName)
	w.N(`
import (
	"context"
	"database/sql"
	"errors"
	"time"
)
`)
	w.N(`
// DB is the common interface for database operations and works with sqlx.DB, and sqlx.Tx.
// Use this IFF the function or method only performs one SQL operation to provide flexibility to the caller.
// If the function or method performs two or more SQL operations, use TX instead.
// This forces the caller to use a transaction and indicates that it's necessary to maintain data consistency.
type DB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
	Get(dest interface{}, query string, args ...interface{}) error
	GetContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error
	NamedExec(query string, arg interface{}) (sql.Result, error)
	NamedExecContext(ctx context.Context, query string, arg interface{}) (sql.Result, error)
	Prepare(query string) (*sql.Stmt, error)
	PrepareContext(ctx context.Context, query string) (*sql.Stmt, error)
	Query(query string, args ...any) (*sql.Rows, error)
	QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...any) *sql.Row
	QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row
	Rebind(query string) string
	Select(dest interface{}, query string, args ...interface{}) error
	SelectContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error
}

// TX is the common interface for database operations requiring a transaction and works with sqlx.Tx.
// Use this IFF the function or method performs two or more SQL operations.
// This forces the caller to use a transaction and indicates that it's necessary to maintain data consistency.
// If the function or method performs only one SQL operation, use DB instead.
type TX interface {
	DB
	Commit() error
	Rollback() error
}

// Stored represents a struct that can be persisted to a SQL database or similar backend.
type Stored interface {
	// Exists in the database.
	Exists() bool
	// Deleted from the database.
	Deleted() bool
	// Insert this row into the database, returning an error on conflicts.
	// Use Upsert if a conflict should not result in an error.
	Insert(context.Context, DB) error
	// Update this existing row in the database.
	Update(context.Context, DB) error
	// Save this row to the database, either using Insert if it exists already, or Update if not.
	Save(context.Context, DB) error
	// Upsert this row to the database (insert or update if it conflicts with an existing row).
	Upsert(context.Context, DB) error
	// Delete this row from the database.
	Delete(context.Context, DB) error
}

var (
	ErrInsertAlreadyExists		= errors.New("cannot insert because the row already exists")
	ErrInsertMarkedForDeletion	= errors.New("cannot insert because the row has been deleted")
	ErrUpdateDoesNotExist		= errors.New("cannot update because the row does not exist")
	ErrUpdateMarkedForDeletion	= errors.New("cannot update because the row has been deleted")
	ErrUpsertMarkedForDeletion	= errors.New("cannot upsert because the row has been deleted")
)
`)
}

// Table converts a Table to its Go-access-layer.
func Table(w *ShortWriter, t *parser.Table) {
	w.F("// %s represents a row from '%s'\n", t.GoName(), t.SQLName())
	if t.Comment != "" {
		w.F("// Schema Comment: %s\n", t.Comment)
	}
	if len(t.PrimaryKeys()) < 1 {
		w.N("//")
		w.N("// Update, Save, Upsert, and Delete methods not provided because we were unable to determine a PK")
	}
	w.F("type %s struct {\n", t.GoName())
	for _, c := range t.Columns {
		columnToGo(w, &c)
	}
	w.N(`	_exists, _deleted bool // In-memory-only metadata on this row's status in the DB`)
	w.F("}\n\n")

	w.N("// Exists in the database.")
	w.F("func (x *%s) Exists() bool {\n", t.GoName())
	w.N("	return x._exists")
	w.F("}\n\n")

	w.N("// Deleted from the database.")
	w.F("func (x *%s) Deleted() bool {\n", t.GoName())
	w.N("	return x._deleted")
	w.N("}\n\n")

	Insert(w, t)
	Update(w, t)
	Save(w, t)
	Upsert(w, t)
	Delete(w, t)
	GetByPk(w, t)
}

// columnToGo converts a Column to its Go-ORM layer.
// Adds a comment about whether this column is Unique, has a Default, and the SQL comment
func columnToGo(w *ShortWriter, c *parser.Column) {
	commentParts := []string{}
	if c.PrimaryKey {
		commentParts = append(commentParts, "PK")
	}
	if c.CompositePrimaryKey {
		commentParts = append(commentParts, "Composite PK")
	}
	if c.Unique {
		commentParts = append(commentParts, "Unique")
	}
	if c.ForeignKey != nil {
		commentParts = append(commentParts, fmt.Sprintf("FK: %s.%s", c.ForeignKey.Table, c.ForeignKey.Column))
	}
	switch {
	case c.DefaultBool.Valid:
		commentParts = append(commentParts, fmt.Sprintf("Default: %v", c.DefaultBool.Bool))
	case c.DefaultString.Valid:
		commentParts = append(commentParts, fmt.Sprintf("Default: %v", c.DefaultString.String))
	case c.DefaultInt.Valid:
		commentParts = append(commentParts, fmt.Sprintf("Default: %v", c.DefaultInt.Int64))
	}
	if c.Comment != "" {
		commentParts = append(commentParts, c.Comment)
	}
	comment := ""
	if len(commentParts) > 0 {
		comment = fmt.Sprintf("// %s", strings.Join(commentParts, ", "))
	}

	w.F("	%s %s `db:\"%s\"` %s\n", c.GoName(), c.Type.ToGo(c.Nullable), c.SQLName(), comment)
}

// Insert
func Insert(w *ShortWriter, t *parser.Table) {
	w.N("// Insert this row into the database, returning an error on conflicts.")
	w.N("// Use Upsert if a conflict should not result in an error.")
	w.F("func (x *%s) Insert(ctx context.Context, db DB) error {\n", t.GoName())
	w.N(`	switch {`)
	w.N(`	case x._exists:`)
	w.N(`		return ErrInsertAlreadyExists`)
	w.N(`	case x._deleted:`)
	w.N(`		return ErrInsertMarkedForDeletion`)
	w.N(`	}`)
	if t.PrimaryKeyAutoIncrements() {
		w.N("	res, err := db.NamedExecContext(ctx, `")
	} else {
		w.N("	_, err := db.NamedExecContext(ctx, `")
	}
	w.F("		INSERT INTO %s (%s)\n", t.SQLName(), InsertColumns(t, false))
	w.F("		VALUES (%s)`, x)\n", InsertColumns(t, true))
	w.N("	if err != nil {")
	w.N("		return err")
	w.N("	}")
	if t.PrimaryKeyAutoIncrements() {
		w.N("	id, err := res.LastInsertId()")
		w.N("	if err != nil {")
		w.N("		return err")
		w.N("	}")
		pks := t.PrimaryKeys()
		if pks[0].Nullable {
			w.N("	x.ID = sql.NullInt64{Valid: true, Int64: id}")
		} else {
			w.N("	x.ID = id")
		}
	}
	w.N("	x._exists = true")
	w.N("	return nil")
	w.N("}\n\n")
}

// Update
func Update(w *ShortWriter, t *parser.Table) {
	if len(t.PrimaryKeys()) < 1 {
		return
	}
	w.N("// Update this row in the database.")
	w.F("func (x *%s) Update(ctx context.Context, db DB) error {\n", t.GoName())
	w.N("	switch {")
	w.N("	case !x._exists: // doesn't exist")
	w.N("		return ErrUpdateDoesNotExist")
	w.N("	case x._deleted: // deleted")
	w.N("		return ErrUpdateMarkedForDeletion")
	w.N("	}")
	w.N("	// update with primary key")
	w.N("	_, err := db.NamedExecContext(ctx, `")
	w.F("			UPDATE %s (%s)\n", t.SQLName(), UpdateColumns(t, false))
	w.F("			VALUES (%s)\n", UpdateColumns(t, true))
	w.F("			WHERE %s`, x)\n", WherePKs(t))
	w.N("	if err != nil {")
	w.N("		return err")
	w.N("	}")
	w.N("	return nil")
	w.N("}\n\n")
}

// Save
func Save(w *ShortWriter, t *parser.Table) {
	if len(t.PrimaryKeys()) < 1 {
		return
	}
	w.N("// Save this row to the database, either using Insert or Update.")
	w.F("func (x *%s) Save(ctx context.Context, db DB) error {\n", t.GoName())
	w.N("	if x.Exists() {")
	w.N("		return x.Update(ctx, db)")
	w.N("	}")
	w.N("	return x.Insert(ctx, db)")
	w.N("}\n\n")
}

// Upsert
func Upsert(w *ShortWriter, t *parser.Table) {
	if len(t.PrimaryKeys()) < 1 {
		return
	}
	w.N("// Upsert this row to the database.")
	w.N("// Note this does not specify a \"conflict target\": https://www.sqlite.org/lang_upsert.html")
	w.F("func (x *%s) Upsert(ctx context.Context, db DB) error {\n", t.GoName())
	w.N("	switch {")
	w.N("	case x._deleted: // deleted")
	w.N("		return ErrUpsertMarkedForDeletion")
	w.N("	}")
	w.N("	_, err := db.NamedExecContext(ctx, `")
	w.F("		INSERT INTO %s (%s)\n", t.SQLName(), InsertColumns(t, false))
	w.F("		VALUES (%s)\n", InsertColumns(t, true))
	w.F("		ON CONFLICT DO UPDATE SET %s`, x)\n", UpsertUpdateColumns(t))
	w.N("	if err != nil {")
	w.N("		return err")
	w.N("	}")
	w.N("	// set exists")
	w.N("	x._exists = true")
	w.N("	return nil")
	w.N("}\n\n")
}

// Delete
func Delete(w *ShortWriter, t *parser.Table) {
	if len(t.PrimaryKeys()) < 1 {
		return
	}
	w.N("// Delete this row from the database.")
	w.F("func (x *%s) Delete(ctx context.Context, db DB) error {\n", t.GoName())
	w.N("	switch {")
	w.N("	case !x._exists: // doesn't exist")
	w.N("		return nil")
	w.N("	case x._deleted:")
	w.N("		return nil")
	w.N("	}")
	w.N("	_, err := db.NamedExecContext(ctx, `")
	w.F("			DELETE FROM %s\n", t.SQLName())
	w.F("			WHERE %s`, x)\n", WherePKs(t))
	w.N("	if err != nil {")
	w.N("		return err")
	w.N("	}")
	w.N("	x._deleted = true")
	w.N("	return nil")
	w.N("}\n\n")
}

// GetByPk
func GetByPk(w *ShortWriter, t *parser.Table) {
	pk := t.PrimaryKeys()
	if len(pk) < 1 {
		return
	}
	// Concatenate each PK (if this uses a composite key) to create the name (e.g. GetByArtistAlbum).
	pkNames := make([]string, len(pk))
	// Create the arguments for this function (e.g. Artist string, Album string).
	pkArgs := make([]string, len(pk))
	pkWhere := make([]string, len(pk))
	for i := range pk {
		pkNames[i] = pk[i].GoName()
		pkArgs[i] = fmt.Sprintf("%s %s", pk[i].GoName(), pk[i].GetGoType())
		pkWhere[i] = fmt.Sprintf("%s=?", pk[i].SQLName())
	}
	funcName := fmt.Sprintf("%sGetBy%s", t.GoName(), strings.Join(pkNames, ""))
	w.F("// %s\n", funcName)
	w.F("func %s(ctx context.Context, db DB, %s) (*%s, error) {\n", funcName, strings.Join(pkArgs, ", "), t.GoName())
	w.F("	row := &%s{}\n", t.GoName())
	w.F("	err := db.Select(&row, `\n")
	w.N("		SELECT *")
	w.F("		FROM %s\n", t.SQLName())
	w.F("		WHERE %s`, %s)\n", strings.Join(pkWhere, ", "), strings.Join(pkNames, ", "))
	w.N("	if err != nil {")
	w.N("		return nil, err")
	w.N("	}")
	w.N("	row._exists = true")
	w.N("	return row, nil")
	w.N("}\n\n")
}

// GetAll
func GetAll(w *ShortWriter, t *parser.Table) {
	pk := t.PrimaryKeys()
	if len(pk) < 1 {
		return
	}
	pkName := ""
	for i := range pk {
		pkName = pkName + pk[i].GoName()
	}
	funcName := fmt.Sprintf("%sGetAll", t.GoName())
	w.F("// %s\n", funcName)
	w.F("func %s(ctx context.Context, db DB) ([]*%s, error) {\n", funcName, t.GoName())
	w.F("	all := []*%s{}\n", t.GoName())
	w.F("	err := db.Select(&all, `\n")
	w.N("		SELECT *")
	w.F("		FROM %s`)\n", t.SQLName())
	w.N("	if err != nil {")
	w.N("		return nil, err")
	w.N("	}")
	w.N("	for i := range all {")
	w.F("		all[i]._exists = true")
	w.N("	}")
	w.N("	return all, nil")
	w.N("}\n\n")
}
